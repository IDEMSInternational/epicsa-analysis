---
title: "Zambia Comparisons"
output: 
  html_document:
    fig_width: 12
    fig_height: 12
---

```{r packages, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(here)
library(ggplot2)
library(lubridate)
library(reshape2)
library(viridis)
library(RColorBrewer)
library(tidyr)
library(hydroGOF)
library(stringr)
library(knitr)
library(kableExtra)
library(rnaturalearthdata)
library(rnaturalearth)
library(ggrepel)
library(sp)
library(tibble)
library(verification)
library(purrr)
library(dplyr)
```

```{r setup, include=FALSE}
source(here("src", "helper_funs.R"))

zm <- readRDS(here("data", "station", "cleaned", "zambia_station_cleaned.RDS"))
if(anyDuplicated(zm %>% dplyr::select(station, date))) stop("Duplicates found!")
zm <- zm %>% 
  dplyr::select(station, date, rain, chirps_rain, chirp_rain, era5_rain, tamsat_rain)
# 1 Aug = 214
s_doy_start <- 214
zm <- zm %>% mutate(doy = yday_366(date),
                    year = year(date),
                    month = month(date),
                    s_doy = (doy - s_doy_start + 1) %% 366,
                    s_doy = ifelse(s_doy == 0, 366, s_doy),
                    syear = year,
                    syear = ifelse(s_doy > (366 - s_doy_start + 1), syear - 1, syear),
                    month = factor(month, levels = c(8:12, 1:7)),
                    month_abb = factor(month, labels = month.abb[c(8:12, 1:7)]),
                    rain = ifelse(rain < 0, 0, rain),
                    era5_rain = ifelse(era5_rain < 0, 0, era5_rain),
                    chirps_rain = ifelse(chirps_rain < 0, 0, chirps_rain), 
                    chirp_rain = ifelse(chirp_rain < 0, 0, chirp_rain), 
                    tamsat_rain = ifelse(tamsat_rain < 0, 0, tamsat_rain)
                    )

zm_long_st <- zm %>% 
  melt(id.vars = c("station", "date", "year", "syear", "month", "month_abb", 
                   "doy", "s_doy", "rain"),
       measure.vars = names(zm)[endsWith(names(zm), "rain")][-1],
       variable.name = "product", value.name = "pr_rain")

zm_long <- zm %>% 
  melt(id.vars = c("station", "date", "year", "syear", "month", "month_abb", "doy", "s_doy"),
       measure.vars = names(zm)[endsWith(names(zm), "rain")],
       variable.name = "product", value.name = "rain") %>%
  mutate(rainday = rain > 1)

zm_long$product <- recode(zm_long$product, rain = "station")

stations <- c("Moorings", "Choma", "Kasama", "Livingstone", "Magoye", "Mansa", "Mpika", "Chipata", "Petauke")
products <- levels(zm_long$product)
products <- products[-1]
names(products) <- substr(products, 1, nchar(products) - 5)

metadata_zm <- readRDS(here("data", "station", "cleaned", "zambia_station_metadata_cleaned.RDS"))

metadata_zm$station <- factor(metadata_zm$station, levels = stations)
zm_long$station <- factor(zm_long$station, levels = stations)

by_station <- zm_long %>%
  group_by(station) %>%
  filter(!is.na(rain) & product == "station") %>%
  summarise(first_date = first(date),
            last_date = last(date))

metadata_zm <- left_join(metadata_zm, by_station, by = "station")
rm(by_station)

zm_long <- left_join(zm_long, metadata_zm, by = "station")

zm_long <- zm_long %>% 
  filter(date >= first_date & date <= last_date)

skable <- function(kable_input) {
  kable_input %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                                full_width = FALSE)
}
```

```{r}
metadata_zm %>% 
  dplyr::select(station, latitude, longitude, first_date, last_date) %>%
  kable(digits = 2) %>%
  skable()
```


```{r station_map, fig.width=9, fig.height=4.5}
sf_zm <- ne_countries(country = "Zambia", returnclass = "sf")
ggplot(sf_zm) + 
  geom_sf() +
  geom_point(data = metadata_zm, aes(x = longitude, y = latitude)) +
  geom_text_repel(data = metadata_zm, aes(x = longitude, y = latitude, label = station))
rm(sf_zm)
```

```{r gof_fun}
dgof <- function(df, sim, obs, na.rm = TRUE) {
  g <- hydroGOF::gof(sim = df[[sim]], obs = df[[obs]], na.rm = na.rm)
  as.list(g[ ,1])
}

comp_stats <- c("r", "ME", "PBIAS %", "MAE", "NSE", "rSD")
names(comp_stats) <- c("Correlation coefficient (1 = Perfect)",
                       "Mean bias (same units)",
                       "Percentage bias (%)",
                       "Mean absolute bias (same units)",
                       "Nash-Sutcliffe efficiency (1 = Perfect)",
                       "Ratio of standard deviations (< 1 less variable, > 1 more variable)")

comp_stats_digits <- c(2, 0, 0, 0, 2, 3)
```

## Yearly Comparisons (August to July)

```{r yearly_calcs}
by_syear <- zm_long %>%
  group_by(station, syear, product) %>%
  summarise(total_rain = sum(naif_nmin(rain, 355)), 
            n_rain = sum(naif_nmin(rain, 355) > 0.1), 
            max_rain = max(naif_nmin(rain, 350)), 
            mean_rain = total_rain/n_rain, 
            n_na = sum(is.na(rain))
            )

by_syear_st <- by_syear %>%
  pivot_wider(id_cols = c(station, syear), 
              names_from = product, values_from = total_rain:n_na, names_sep = "__") %>%
  pivot_longer(cols = -c(station, syear, ends_with("station")), 
               names_to = c(".value", "product"), names_sep = "__")

gof_syear <- by_syear_st %>%
  group_by(station, product) %>%
  nest() %>%
  mutate(n = purrr::map_int(data, 
                        ~sum(!is.na(.$total_rain__station) & !is.na(.$total_rain))),
         gof__total_rain = purrr::map(data, dgof, "total_rain", "total_rain__station", 
                                      na.rm = TRUE),
         gof__n_rain = purrr::map(data, dgof, "n_rain", "n_rain__station", na.rm = TRUE),
         gof__mean_rain = purrr::map(data, dgof, "mean_rain", "mean_rain__station", 
                                     na.rm = TRUE)
         )

gof_pr <- gof_syear %>% 
  unnest(cols = data) %>% 
  group_by(product) %>% 
  nest()
```

```{r yearly_plots_fun}
yearly_plots <- function(df, gof_col, stat_pr, stat_st, product_name) {
  max_y <- max(c(df[[stat_pr]], df[[stat_st]]), na.rm = TRUE)
  vals_relace <- c(product_name, "station")
  names(vals_relace) <- c(stat_pr, stat_st)
  dat <- df %>% 
    pivot_longer(cols = c(stat_pr, stat_st), names_to = "product", values_to = stat_pr) %>%
    mutate(product = recode(product, !!!vals_relace),
           ME = purrr::map_dbl(.data[[gof_col]], "ME"),
           r = purrr::map_dbl(.data[[gof_col]], "r"),
           rSD = purrr::map_dbl(.data[[gof_col]], "rSD")
           )
  mean_df <- dat %>% 
    group_by(station, product) %>% 
    summarise(m = mean(.data[[stat_pr]], na.rm = TRUE))
  g <- ggplot(dat, aes(x = syear, y = .data[[stat_pr]], colour = product)) +
    geom_line() +
    geom_point() +
    geom_hline(data = mean_df, aes(yintercept = m, colour = product)) +
    scale_x_continuous(limits = c(1979, 2012)) +
    # n
    geom_text(data = dat, aes(label = paste("n", n)), size = 4,
              x = 1979, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # bias
    geom_text(data = dat, aes(label = paste("bias", signif(ME, 2))), 
              size = 4, x = 1979 + 6, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # cor
    geom_text(aes(label = paste("cor", round(r, 2))), 
              size = 4, x = 1979 + 14, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    # rSD
    geom_text(aes(label = paste("rSD", round(rSD, 2))), 
              size = 4, x = 1979 + 22, y = max_y, na.rm = TRUE, 
              inherit.aes = FALSE) +
    ggtitle(paste(stat_pr, ":", product_name, "vs", "station")) +
    facet_wrap(~station)
  g
}
```

```{r stats_tables_fun}
stats_tables <- function(df, obj_col, obj_stats = comp_stats) {
  for(i in seq_along(obj_stats)) {
    dat <- df %>% 
      ungroup() %>%
      mutate(purrr::map_dbl(df[[obj_col]], obj_stats[i]))
    names(dat)[ncol(dat)] <- obj_stats[i]
    dat <- dat %>% 
      mutate(station = as.character(station)) %>%
      pivot_wider(id_cols = "station", names_from = "product", 
                  values_from = obj_stats[[i]]) %>%
      data.frame()
  dat[nrow(dat) + 1, ] <- c(list("(All)"), as.list(as.numeric(colMeans(dat[ , -1]))))
  dat %>%
    kable(digits = comp_stats_digits[i], caption = names(obj_stats[i]), 
          format.args = list(big.mark = ",")) %>%
    skable() %>%
    row_spec(nrow(dat), bold = TRUE) %>%
    print()
  }
}
```

### Comparison Statistics for Total Yearly Rainfall

- In general all products follow a similar shape each year (high correlation, except Chirp)
- All products, apart from ERA5, estimate the mean quite well (low bias and low percentage bias).
- ERA5 overestimates (high bias)
- Aside from Chirps, the products do not have very good predictive skill (Nash-Sutcliffe efficiency, usually very close to 0 or less than 0)
- CHIRPS performs well over all measures
- Slightly less variability in all products, between 70% - 90% (except Era5, that has higher variability in 4 out of the 8 stations considered).
- Chipata has weired station values between 2005 and 2010 (needs investigation).

```{r yearly_total_plots}
p_syear_total <- gof_pr %>%
  mutate(p = purrr::map(data, yearly_plots, gof_col = "gof__total_rain", 
                        stat_pr = "total_rain", stat_st = "total_rain__station", 
                        product_name = product),
         paths = here("results", "zambia", 
                      paste0("zambia_", "syear_", "total_rain", "_", product, ".png")))

walk2(p_syear_total$paths, p_syear_total$p, ggsave, width = 12, height = 6)
walk(p_syear_total$p, print)
```

```{r yearly_n_obs, results="asis"}
dat <- gof_syear %>% 
  dplyr::select(station, product, n) %>%
  pivot_wider(id_cols = c(station), names_from = product, values_from = n)

names(dat)[endsWith(names(dat), "rain")] <- 
  substr(names(dat)[endsWith(names(dat), "rain")], 
         1, nchar(names(dat)[endsWith(names(dat), "rain")]) - 5)
dat %>%
  kable(caption = "Number of years compared") %>%
  skable()
```

```{r yearly_total_rain_tables, results="asis"}
stats_tables(gof_syear, "gof__total_rain")
```

### Comparison Statistics for Number of rainy days

- Not so good correlation across the products
- All products overestimate number of rainy days (generally with higher biases)
- Almost the same variability as stations for all products 
- All products have not so good predictive skill



```{r yearly_n_rain_plots}
p_syear_n <- gof_pr %>%
  mutate(p = purrr::map(data, yearly_plots, gof_col = "gof__n_rain", 
                        stat_pr = "n_rain", stat_st = "n_rain__station", 
                        product_name = product),
         paths = here("results", "zambia", 
                      paste0("zambia_", "syear_", "n_rain", "_", product, ".png")))

walk2(p_syear_n$paths, p_syear_n$p, ggsave, width = 12, height = 6)
walk(p_syear_n$p, print)
```

```{r yearly_n_rain_tables, results="asis"}
stats_tables(gof_syear, "gof__n_rain")
```

## Monthly Comparisons (November to April)

```{r monthly_calcs}
by_month <- zm_long %>%
  group_by(station, syear, month_abb, product) %>%
  filter(month %in% c(11:12, 1:4)) %>%
  summarise(total_rain = sum(naif_nmin(rain, 25)), 
            n_rain = sum(naif_nmin(rain, 25) > 0.1), 
            max_rain = max(naif_nmin(rain, 20)), 
            mean_rain = total_rain/n_rain, 
            n_na = sum(is.na(rain))
            )

by_month_st <- by_month %>%
  pivot_wider(id_cols = c(station, syear, month_abb), 
              names_from = product, values_from = total_rain:n_na, names_sep = "__") %>%
  pivot_longer(cols = -c(station, syear, month_abb, ends_with("station")), 
               names_to = c(".value", "product"), names_sep = "__")

gof_month <- by_month_st %>%
  group_by(station, product) %>%
  nest() %>%
  mutate(n = purrr::map_int(data, 
                        ~sum(!is.na(.$total_rain__station) & !is.na(.$total_rain))),
         gof__total_rain = purrr::map(data, dgof, "total_rain", "total_rain__station", 
                                      na.rm = TRUE),
         gof__n_rain = purrr::map(data, dgof, "n_rain", "n_rain__station", na.rm = TRUE),
         # gof__mean_rain = purrr::map(data, dgof, "mean_rain", "mean_rain__station", 
         #                             na.rm = TRUE)
         )

gof_pr_month <- gof_month %>%
  unnest(cols = data) %>% 
  group_by(product) %>% 
  nest()
```

```{r monthly_plots_fun}
monthly_plots <- function(df, stat_pr, stat_st, product_name) {
  vals_relace <- c(product_name, "station")
  names(vals_relace) <- c(stat_pr, stat_st)
  dat <- df %>% 
    filter(month_abb %in% month.abb[c(11:12, 1:4)]) %>%
    pivot_longer(cols = c(stat_pr, stat_st), names_to = "product", values_to = stat_pr) %>%
    mutate(product = recode(product, !!!vals_relace))

  mean_df <- dat %>% 
    group_by(station, product, month_abb) %>% 
    summarise(m = mean(.data[[stat_pr]], na.rm = TRUE))

  g <- ggplot(dat, aes(x = syear, y = .data[[stat_pr]], colour = product)) +
    geom_line() +
    geom_point() +
    #geom_hline(data = mean_df, aes(yintercept = m, colour = product)) +
    scale_x_continuous(limits = c(1979, 2012)) +
    ggtitle(paste(stat_pr, ":", product_name, "vs", "station")) +
    facet_grid(station~month_abb)
  g
}
```

### Comparison statistics for total monthly rainfall
- In general all products follow a similar shape each year (high correlation)
- All products, apart from ERA5, estimate the mean quite well (low bias and low percentage bias), with a very slight underestimation compared to yearly totals
- ERA5 overestimates (high bias) 
- CHIRPS performs well over all measures. 
- Slightly less variability in all products, between 85% - 95%
- Generally higher correlations and better s.d. ratios than yearly totals

```{r monthly_plots_total_rain}
p_month_total <- gof_pr_month %>%
  mutate(p = purrr::map(data, monthly_plots, stat_pr = "total_rain", 
                        stat_st = "total_rain__station", product_name = product),
         paths = here("results", "zambia", 
                      paste0("zambia_", "month_", "total_rain", "_", product, ".png")))

walk2(p_month_total$paths, p_month_total$p, ggsave, width = 12, height = 12)
walk(p_month_total$p, print)
```

```{r monthly_tables_total_rain, results="asis"}
stats_tables(gof_month, "gof__total_rain")
```
### Comparison statistics for number of monthly raindays
- Generally high correlation for all products
- Generally the products have about the same or slightly higher or slightly lower variability
- All products overestimate the number of rainy days but it is the least for Chirps

```{r monthly_plots_n_rain}
p_month_total <- gof_pr_month %>%
  mutate(p = purrr::map(data, monthly_plots, stat_pr = "n_rain", 
                        stat_st = "n_rain__station", product_name = product),
         paths = here("results", "zambia", 
                      paste0("zambia_", "month_", "n_rain", "_", product, ".png")))

walk2(p_month_total$paths, p_month_total$p, ggsave, width = 12, height = 12)
walk(p_month_total$p, print)
```

```{r monthly_tables_n_rain, results="asis"}
stats_tables(gof_month, "gof__n_rain")
```


## Markov Chain models of the chance of rain
* All products model the same shape of chance of rain
* All overestimate the chance of rain
* With a higher rain day threshold on the product data the probabilities can be made to match very closely
* Threshold between 2 and 5 mm depending on the product
* The optimum threshold may depend on the station

```{r markov_chain_setup}
zambia_markov <- zm_long_st %>% 
  filter(!is.na(rain) & !is.na(pr_rain)) %>%
  mutate(rainday1 = rain > 0.85,
         pr_rainday1 = pr_rain > 0.85,
         pr_rainday3 = pr_rain > 3,
         pr_rainday4 = pr_rain > 4,
         pr_rainday5 = pr_rain > 5,
         pr_rainday2max = pr_rain > 1 & pr_rain <= 2,
         pr_rainday3max = pr_rain > 1 & pr_rain <= 3,
         pr_rainday4max = pr_rain > 1 & pr_rain <= 4,
         pr_rainday5max = pr_rain > 1 & pr_rain <= 5)

f_zero_order_station <- rainday1 ~ (cos(s_doy * 1 * 2 * pi/366) +
                                    sin(s_doy * 1 * 2 * pi/366) + 
                                    cos(s_doy * 2 * 2 * pi/366) + 
                                    sin(s_doy * 2 * 2 * pi/366) +
                                    cos(s_doy * 3 * 2 * pi/366) +
                                    sin(s_doy * 3 * 2 * pi/366))
f_zero_order_product <- update.formula(f_zero_order_station, pr_rainday1 ~ .)

predict_stack_lst <- list()
for(s in seq_along(stations)) {
  predict_df <- data.frame(station = stations[s], s_doy = 1:366,
                           s_doy_date = as.Date(1:366, origin = as.Date("1999/07/31")))
  dat <- zambia_markov %>%
    filter(station == stations[s])
  for(i in seq_along(products)) {
    dat_prod <- dat %>%
      filter(product %in% c("station", products[i])) %>% 
      filter(!is.na(rain) & !is.na(pr_rain))
    zero_order_station <- glm(f_zero_order_station, data = dat_prod, family = binomial)
    zero_order_product <- glm(f_zero_order_product, data = dat_prod, family = binomial)
    #print(anova(zero_order_station, test="Chisq"))
    predict_df[[paste0("station", "_", products[i])]] <- predict(zero_order_station, 
                                                                 newdata = predict_df, 
                                                                 type = "response")
    predict_df[[products[i]]] <- predict(zero_order_product, newdata = predict_df, 
                                         type = "response")
    
    f_zero_order_product_3thres <- update.formula(f_zero_order_station, pr_rainday3 ~ .)
    f_zero_order_product_4thres <- update.formula(f_zero_order_station, pr_rainday4 ~ .)
    f_zero_order_product_5thres <- update.formula(f_zero_order_station, pr_rainday5 ~ .)
    f_zero_order_product_2max <- update.formula(f_zero_order_station, pr_rainday2max ~ .)
    f_zero_order_product_3max <- update.formula(f_zero_order_station, pr_rainday3max ~ .)
    f_zero_order_product_4max <- update.formula(f_zero_order_station, pr_rainday4max ~ .)
    f_zero_order_product_5max <- update.formula(f_zero_order_station, pr_rainday5max ~ .)
    fms <- list(f_zero_order_product_2max, f_zero_order_product_3max, 
                f_zero_order_product_4max, f_zero_order_product_5max)
    fms_thres <- list(f_zero_order_product_3thres, f_zero_order_product_4thres,
                      f_zero_order_product_5thres)
    mds <- list()
    for(j in 2:(2 + length(fms) - 1)) {
      zero_order <- glm(fms[[j - 1]], data = dat_prod, family = binomial)
      predict_df[[paste0(products[i], "_", j, "max")]] <- predict(zero_order, 
                                                                  newdata = predict_df, 
                                                                  type = "response")
    }
    for(j in 3:(3 + length(fms_thres) - 1)) {
      zero_order <- glm(fms_thres[[j - 2]], data = dat_prod, family = binomial)
      predict_df[[paste0(products[i], "_", j, "thres")]] <- predict(zero_order, 
                                                                    newdata = predict_df, 
                                                                    type = "response")
    }
  }
  
  predict_stack <- predict_df %>% melt(id.vars = c("station", "s_doy", "s_doy_date"), 
                                       variable.name = "product", value.name = "prob")

  predict_stack$product <- as.character(predict_stack$product)
  predict_stack$product2 <- predict_stack$product
  predict_stack$type <- "product1"
  
  predict_stack <- predict_stack %>% 
    mutate(type = ifelse(startsWith(product, "station"), "station1", type),
           type = ifelse(endsWith(product, "max"), 
                         substr(product, nchar(product) - 3, nchar(product)), type),
           type = ifelse(endsWith(product, "thres"), 
                         substr(product, nchar(product) - 5, nchar(product)), type),
           product2 = ifelse(startsWith(product, "station"), 
                             substr(product, 9, nchar(product)), product2),
           product2 = ifelse(endsWith(product, "max"), 
                             substr(product, 1, nchar(product) - 5), product2),
           product2 = ifelse(endsWith(product, "thres"), 
                             substr(product, 1, nchar(product) - 7), product2)
           )
  
  predict_stack$type <- factor(predict_stack$type, levels = unique(predict_stack$type))
  predict_stack_lst[[length(predict_stack_lst) + 1]] <- predict_stack
  # Plot small amounts
  # g <- ggplot(predict_stack, aes(x = s_doy, y = prob, colour = type)) +
  #   geom_line() +
  #   facet_wrap(~product2) +
  #   scale_color_manual(values = c("black", c25[1:7])) +
  #   ggtitle(paste("Chance of rain:", stations[s]))
  # ggsave(here("results", "zambia", paste0("zambia_", "markov_zero", stations[s], ".png")), 
  #        plot = g, width = 12, height = 6)
}
predict_stack_all <- bind_rows(predict_stack_lst)
```

```{r markov_chain_plots_stations}
for(s in seq_along(stations)) {
  dat <- predict_stack_all %>% filter(station == stations[s] & !grepl("max", type))
  g <- ggplot(dat, aes(x = s_doy_date, y = prob, colour = type, size = type)) +
    geom_line() +
    facet_wrap(~product2) +
    scale_size_manual(values = c(0.8, rep(0.6, 4))) +
    scale_color_manual(values = c("black", c25[1:4])) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b") +
    ggtitle(paste("Chance of rain:", stations[s]))
  print(g)
  ggsave(here("results", "zambia", 
              paste0("zambia_", "markov_zero", "_station_", stations[s], ".png")),
         plot = g, width = 12, height = 6)
}
```

```{r markov_chain_plots_products}
for(s in seq_along(products)) {
  dat <- predict_stack_all %>% 
    filter(product2 == products[s] & !grepl("max", type))
  g <- ggplot(dat, aes(x = s_doy_date, y = prob, 
                       colour = type, size = type, linetype = type)) +
    geom_line() +
    facet_wrap(~station) +
    scale_color_manual(values = c("black", viridis(4, end = 0.8))) +
    scale_size_manual(values = c(1.3, rep(0.8, 4))) +
    scale_x_date(date_breaks = "2 months", date_labels = "%b") +
    scale_linetype_manual(values = c("solid", rep("longdash", 4))) +
    ggtitle(paste("Chance of rain:", products[s]))
  print(g)
  ggsave(here("results", "zambia", 
              paste0("zambia_", "markov_zero", "_product_", names(products)[s], ".png")),
         plot = g, width = 12, height = 6)
}
```

### Distribution of rainfall amounts
```{r}
prop_amounts <- zm_long %>%
  filter(rain > 0.85 & station == "Livingstone") %>%
  mutate(rain_grps = cut(rain,
                          breaks = c(0, 5.1, 20, 50, 200),
                          include.lowest = TRUE)) %>%
  group_by(product, rain_grps) %>%
  summarise(n = n()) %>%
  mutate(prop = n/sum(n), cumul = cumsum(prop))

ggplot(prop_amounts, aes(x = rain_grps, y = prop, fill = product)) +
  geom_col(position = "dodge")

prop_amounts %>%
  pivot_wider(names_from = product, values_from = cumul, id_cols = rain_grps) %>%
  kable(digits = 2) %>%
  skable()
```

### Detection of rainfall on the same days (November to April)

![](cont_table.jpeg)

- In general these results confirm what was seen above
- 65 - 75 % accuracy for all products.
- High bias for all products, as already known (more rainy days estimated than observed)
- High hit rate and false alarm ratios, which is expected because of high bias
- Proportion of misses is reassuringly low across products
- Performance will change if different thresholds are introduced

```{r raindays_verify}
raindays <- zm_long_st %>% 
  mutate(st_rainday0p85 = rain > 0.85,
         pr_rainday0p85 = pr_rain > 0.85,
         pr_rainday3 = pr_rain > 3,
         pr_rainday5 = pr_rain > 5)

sverify <- function(df, obs, pred) {
  v <- verification::verify(obs = df[[obs]], pred = df[[pred]], 
                       obs.type = "binary", frcst.type = "binary")
  class(v) <- "list"
  v
}

by_st_pr <- raindays %>%
  group_by(station, product) %>%
  nest() %>%
  mutate(v = purrr::map(data, sverify, obs = "st_rainday0p85", pred = "pr_rainday0p85"),
         bias = purrr::map_dbl(v, "BIAS"))
```

```{r cont_tables, results="asis"}
cont_tables <- function(df, name) {
  df %>%
    kable(caption = name, digits = 2, format.args = list(big.mark = ",")) %>%
    skable() %>%
    row_spec(nrow(df), bold = TRUE)
}

rain_levs <- c("rain", "no_rain")
ver_zm <- raindays %>%
  group_by(product, station) %>%
  filter(month %in% c(11:12, 1:4)) %>%
  filter(!is.na(st_rainday0p85) & !is.na(pr_rainday0p85)) %>%
  summarise(hit = sum(st_rainday0p85 & pr_rainday0p85),
            fa = sum(!st_rainday0p85 & pr_rainday0p85),
            miss = sum(st_rainday0p85 & !pr_rainday0p85),
            cneg = sum(!st_rainday0p85 & !pr_rainday0p85),
            n = n(),
            accuracy = (hit + cneg)/n,
            bias = (hit + fa)/(hit + miss),
            hit_rate = hit/(hit + miss),
            far = fa/(hit + fa),
            ts = hit/(hit + miss + fa),
            ets = verification::verify(obs = st_rainday0p85, pred = pr_rainday0p85, 
                                       obs.type = "binary", frcst.type = "binary")$ETS,
            miss_frac = miss/n #,
            #hk = (hit/(hit + miss) - (fa/(fa + cneg))),
            #hss = verification::verify(obs = st_rainday0p85, pred = pr_rainday0p85, 
                                       #obs.type = "binary", frcst.type = "binary")$HSS
            ) %>%
  arrange(product, station)

measures <- c("accuracy", "bias", "hit_rate", "far", "ts", "ets", "miss_frac")#, "hk", "hss")
names(measures) <- c("Accuracy: What fraction of the estimates were correct?
                     (hits + correct negative)/total (1 = perfect)",
                     "Bias: Ratio of number of rain days from estimate over number of rain days from station. 
                     (hits + false alarms)/(hits + misses) (1 = perfect)",
                     "Hit rate (probability of detection) What fraction of the station rain days were correctly estimated? hits/(hits + misses) (1 = perfect)",
                     "False alarm ratio: What fraction of the estimated rain days actually did not rain? false alarms/(hits + false alarms)",
                     "Threat score: How well did the estimate rain days correspond to the observed rain days?",
                     "Equitable threat score: How well did the estimate rain days correspond to the station rain days (accounting for hits due to chance)?",
                     "Proportion of misses: How many rain days in the station were not detected by the estimate?"#,
                     #"Hanssen and Kuipers discriminant: How well did the forecast separate the rainy days from the dry days? Uses all elements in the contingency table.",
                     #"Heidke skill score: What was the accuracy of the forecast relative to that of random chance? Measures the fraction of correct estimates after eliminating those estimates which would be correct due purely to random chance."
                     )
for(i in seq(measures)) {
  df <- ver_zm %>% 
    dplyr::select(product, station, measures[[i]]) %>%
    pivot_wider(id_cols = station, names_from = product, values_from = measures[[i]])
  names(df)[endsWith(names(df), "rain")] <- substr(names(df)[endsWith(names(df), "rain")],
                                                   1, 
                                                   nchar(names(df)
                                                         [endsWith(names(df), "rain")]
                                                         ) 
                                                   - 5)
  df[nrow(df) + 1, ] <- c(list("(All)"), as.list(as.numeric(colMeans(df[ , -1]))))
  print(cont_tables(df, names(measures)[i]))
}
```


